function nrrdwrite(varargin)
% Write data in nrrd format
% Arguments
% - filename: output file name
% - X: array data to be written
% - meta: struct from nrrdread

% Input parser for parsing input commands
p = inputParser;

addRequired(p, 'filename', @isstr);
addRequired(p, 'data', @(x) isnumeric(x) || islogical(x));
addRequired(p, 'meta', @isstruct);
addParameter(p, 'SuppressWarnings', true, @islogical);
addParameter(p, 'FlipAxes', true, @islogical);
addParameter(p, 'AsciiDelimeter', '\n', @ischar);
addParameter(p, 'UseStringVectorQuotationMarks', false, @islogical);

parse(p, varargin{:});

filename = p.Results.filename;
data = p.Results.data;
meta = p.Results.meta;

% Do in temporary file and copy over for zip, gzip, later

% If encoding is not specified, set to gzip by default
if ~isfield(meta, 'encoding')
    meta.encoding = 'gzip';
end

% If endianness is not specified, set to the endianness of architecture
if ~isfield(meta, 'endian')
    [~, ~, endian] = computer();

    if endian == 'L' 
        meta.endian = 'little';
    else 
        meta.endian = 'big';
    end
end

% Set the data type, number of dimensions and size
% These fields could be out of date or incorrect, so it is best just to
% update these fields
meta.type = getNRRDDatatype(class(data));

% Handle special case of a vector because ndims returns 2 for a vector even
% though one dimension is length 1
if isvector(data)
    meta.dimension = 1;
    meta.sizes = length(data);
else
    meta.dimension = ndims(data);
    meta.sizes = fliplr(size(data));
end

% Open file for writing
fid = fopen(filename, 'wb');
assert(fid > 0, 'Could not open file.');

% Write magic string and header comments
fprintf(fid, 'NRRD0005\n');
fprintf(fid, '# This NRRD file was generated by nrrdwrite\n');
fprintf(fid, '# Complete NRRD file format specification at:\n');
fprintf(fid, '# http://teem.sourceforge.net/nrrd/format.html\n');

% Retrieve field names from metadata
fieldNames = fieldnames(meta);

% Sort field names such that it follows the field order structure. All
% fields not specified in the field order are placed at the end of the
% field names array
fieldOrder = {'type' ...
    'dimension' ...
    'spacedimension' ...
    'space' ...
    'sizes' ...
    'spacedirections' ...
    'kinds' ...
    'endian' ...
    'encoding' ...
    'min' ...
    'max' ...
    'oldmin' ...
    'old min' ...
    'oldmax' ...
    'old max' ...
    'content' ...
    'sample units' ...
    'spacings' ...
    'thicknesses' ...
    'axismins' ...
    'axismaxs' ...
    'centerings' ...
    'labels' ...
    'units' ...
    'spaceunits' ...
    'spaceorigin' ...
    'measurementframe' ...
    'datafile'};

% Loop through each of the fieldOrder fields, find it in the metadata. If
% found, then this is added to the sorted field names array and removed
% from the field names array.
sortedFieldNames = {};
for kk = 1:length(fieldOrder)
    field = fieldOrder{kk};

    idx = find(strcmp(fieldNames, field));

    if ~isempty(idx)
        sortedFieldNames = [sortedFieldNames; field];
        fieldNames(idx) = [];
    end
end

% Append sorted field names to the beginning of field names
% Any field names not found in fieldOrder will be at the back in the same
% order they were read in with nrrdread (or in order of when the field was
% updated last).
fieldNames = [sortedFieldNames; fieldNames];

% If fieldMap field is present in the metadata, then copy it over to a
% local variable and otherwise create an empty local variable fieldMap
% This is used to get the field name that should be written to the file. It
% is useful for fields that had spaces in them but were removed when
% reading them in (struct's fields cannot have spaces)
if isfield(meta, 'fieldMap')
    fieldMap = meta.fieldMap;
    fieldNames(strcmp(fieldNames, 'fieldMap')) = [];
else
    fieldMap = {};
end

% Loop through the sorted field names and write to file one by one
for kk = 1:length(fieldNames)
    % Get field name and the field value (converted to string)
    field = fieldNames{kk};
    value = getFieldValueStr(field, meta.(field), ...
        p.Results.SuppressWarnings, p.Results.UseStringVectorQuotationMarks);

    % If the field name is present in the fieldMap, then use the mapped
    % value. This will useful for replacing spaces when writing the field
    % to the file (e.g. 'spacedirections' maps to 'space directions')
    if ~isempty(fieldMap)
        index = find(strcmp(fieldMap(:, 1), field));
        if ~isempty(index)
            field = fieldMap{index, 2};
        end
    end

    % Write the field and value to the file
    fprintf(fid, '%s: %s\n', field, value);
end

% Append a blank space to the file to indicate data is coming next
fprintf(fid, '\n');

% NRRD states that the dimensions specified are set in terms of the fastest
% dimension to the slowest changing dimension
% This is coined traditional C-ordering in memory but MATLAB uses Fortran
% ordering which is the opposite.
% Thus, if FlipAxes is set, the axes are flipped to correct this
if p.Results.FlipAxes
    % Get order of dimensions by reversing them
    % Permute data
    order = fliplr(1:ndims(data));
    data = permute(data, order);
end

writeData(fid, meta, data, p.Results.AsciiDelimeter);

% Write binary data in raw format
% dims = sscanf(meta.sizes, '%d');
% ndims = sscanf(meta.dimension, '%d');

% X = reshape(X, dims');
% X = permute(X, [2 1 3]);
% fwrite(fid,X,meta.type);

% XXX

% Close file
cleaner = onCleanup(@() fclose(fid));


function NRRDDataType = getNRRDDatatype(dataType)

% Determine the datatype
switch (dataType)
    case {'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64' ...
            'uint64', 'double'}
        NRRDDataType = dataType;

    case {'single'}
        NRRDDataType = 'float';

    otherwise
        assert(false, 'Unknown datatype')
end
end


function [str] = getVectorStr(value, formatStr, delimeter)
    % Since num2str only works on arrays and arrays will concatenate
    % all strings together returning one large string, this causes
    % issue for variable precision on doubles. 
    % To solve this, the array is turned into a cell array, then each
    % cell is converted to a string resulting in a cell array of strings
    % Finally, the cell array is joined by a delimeter
    values = cellfun(@(x) num2str(x, formatStr), num2cell(value), 'UniformOutput', false);
    str = strjoin(values, delimeter);
end


function str = getFieldValueStr(field, value, SuppressWarnings, ...
                            UseStringVectorQuotationMarks)

switch (field)
    % Handle 32-bit ints
    case {'dimension', 'lineskip', 'byteskip', 'spacedimension'}
        str = num2str(value, '%i');

    % Handle doubles
    case {'min', 'max', 'oldmin', 'oldmax'}
        % Note: Double precision can store at maximum 16 decimal places
        str = num2str(value, '%.16g');

    % Handle strings
    case {'type', 'endian', 'encoding', 'content', 'sampleunits', 'datafile', 'space'}
        str = value;

    % Handle vectors that should have int datatype 
    case {'sizes'}
        str = getVectorStr(value, '%i', ' ');

    % Handle vectors that should have double datatype
    case {'spacings', 'thicknesses', 'axismins', 'axismaxs'}
        str = getVectorStr(value, '%.16g', ' ');

    % Handle array of strings
    case {'kinds', 'centerings'}
        str = strjoin(value, ' ');

    % Handle array of strings (has quotation marks around them in official
    % standard)
    case {'labels', 'units', 'spaceunits'}
        % In the official NRRD standard, there are a few fields that have
        % quotation marks around each string that is present. When using
        % NRRD's tool to create files, it follows the standard and includes
        % the quotation marks but I have seen some implementations (such as
        % pynrrd, Slicer) that does not use quotation marks.
        % UseStringVectorQuotationMarks is a parameter that allows turning
        % this on/off. By default, it is off because I don't think the
        % quotations are necessary most of the time.
        if UseStringVectorQuotationMarks
            str = ['"' strjoin(value, '" "') '"'];
        else
            str = strjoin(value, ' ');
        end

    % Handle matrices of double datatype
    case {'spacedirections', 'spaceorigin'}
        str = '';

        for k = 1:size(value, 1)
            if all(isnan(value(k, :)))
                str = [str 'none '];
            else
                vectorStr = getVectorStr(value(k, :), '%.16g', ',');
                str = [str '(' vectorStr ') '];
            end
        end

        str(end) = [];

    % Handle matrices of int datatype
    case {'measurementframe'}
        str = '';

        for k = 1:size(value, 1)
            if all(isnan(value(k, :)))
                str = [str 'none '];
            else
                vectorStr = getVectorStr(value(k, :), '%i', ',');
                str = [str '(' vectorStr ') '];
            end
        end

        str(end) = [];

    otherwise
        if ~SuppressWarnings
            warning(['Unknown field ' field]);
        end
        str = value;
end
end


function writeData(fid, meta, data, AsciiDelimeter)

switch (meta.encoding)
    case {'raw'}
        % Note: Machine format takes in l or b for little or big endian, so
        % this is accomplished by grabbing first letter from endian field
        % of metadata.
        fwrite(fid, data, class(data), 0, meta.endian(1));

    case {'gzip', 'gz'}
        % Create and open temporary file to store the GZIP file to be
        % decompressed
        tmpBase = tempname();
        tmpFile = [tmpBase '.gz'];
        fidTmp = fopen(tmpFile, 'wb');
        assert(fidTmp > 3, 'Could not open temporary file for GZIP decompression')

        % Read data from file and place into temporary file
        tmp = fread(fidIn, inf, 'uint8=>uint8');
        fwrite(fidTmp, tmp, 'uint8');
        fclose(fidTmp);

        % Unzip the temporary file now
        gunzip(tmpFile)

        % Open the unzipped file
        fidTmp = fopen(tmpBase, 'rb');
        cleaner = onCleanup(@() fclose(fidTmp));

        % Read the data from the unzipped file
        data = fread(fidTmp, inf, [meta.type '=>' meta.type]);

    case {'txt', 'text', 'ascii'}
        % Get the formatSpec string based on the data type
        % Note: Double precision can store at maximum 16 decimal places
        % Single precision can store at maximum 7 decimal places.
        switch (class(data))
            case {'double'}, formatSpec = '%.16g';
            case {'single'}, formatSpec = '%.7g';
            otherwise, formatSpec = '%i';
        end

        % Print the data matrix to the file using fprintf
        % For the special case of a 2D matrix, the ASCII text is written in
        % rows and columns to look nice.
        if meta.dimension == 2
            % Go row by row (i.e. y-value) and print the row. Follow the
            % row printing with a newline
            for y = 1:size(data, 2)
                str = getVectorStr(data(:, y), formatSpec, ' ');
                fprintf(fid, [str '\n']);
            end
        else
            % Print the data matrix using the AsciiDelimeter parameter
            formatSpec = [formatSpec AsciiDelimeter];
            fprintf(fid, formatSpec, data);
        end

    otherwise
        assert(false, 'Unsupported encoding')
end
end

end